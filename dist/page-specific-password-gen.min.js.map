{"version":3,"sources":["crypt/hex2base64.js","crypt/pbkdf2.js","crypt/sha1.js","password_lib.js"],"names":["hexToBase64","str","btoa","String","fromCharCode","apply","replace","split","base64ToHex","i","bin","atob","hex","length","tmp","charCodeAt","toString","join","PBKDF2","password","salt","num_iterations","num_bytes","m_result_func","m_status_func","m_bpassword","rstr2binb","m_salt","m_total_iterations","m_iterations_in_chunk","m_iterations_done","m_key_length","m_hash","m_hash_length","m_total_blocks","Math","ceil","m_current_block","m_ipad","Array","m_opad","m_buffer","m_key","m_this_object","this","m_stopped","binb_sha1","chrsz","deriveKey","status_callback","result_callback","setTimeout","do_PBKDF2_iterations","iterations","salt_block","concat","j","rstr2hex","binb2rstr","substr","stop","hex_sha1","s","rstr_sha1","str2rstr_utf8","b64_sha1","rstr2b64","any_sha1","e","rstr2any","hex_hmac_sha1","k","d","rstr_hmac_sha1","b64_hmac_sha1","any_hmac_sha1","sha1_vm_test","toLowerCase","key","data","bkey","ipad","opad","hash","input","hexcase","x","hex_tab","output","charAt","b64pad","tab","len","triplet","encoding","q","quotient","divisor","remainders","dividend","floor","full_length","log","y","str2rstr_utf16le","str2rstr_utf16be","w","a","b","c","olda","oldb","oldc","oldd","olde","bit_rol","t","safe_add","sha1_ft","sha1_kt","lsw","msw","num","cnt","mypbkdf2","passwordLib","calculatePassword","originalPassword","url","options","Promise","resolve","reject","intOptions","getDefaultOptions","attrname","verbose","console","trim","domain","getDomain","getBaseUrl","baseIterations","intResultCallback","calculatePasswordInternal","statusCallback","resultCallback","rejectCallback","base64","typeCount","smallChars","capitalChars","numbers","specialChars","prefix","newPassword","specialCharsListStart","specialCharList","smallCharsAdded","capitalCharsAdded","numbersAdded","specialCharsAdded","charAdded","curChar","charCode","substring","calculatePasswordOld","saltedPassword","moduloSpecialChars","moduloLargeChars","tempPassword","isNaN","parseInt","toUpperCase","character","parts","reverse","match","origUrl","parser","document","createElement","origUrlLower","href","host","indexOf","hostname","undefined","window","tableStr","table","test","Error","n"],"mappings":"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","file":"page-specific-password-gen.min.js","sourcesContent":["/*\n * Licence: cc by-sa 3.0 (https://creativecommons.org/licenses/by-sa/3.0)\n * Source: http://stackoverflow.com/questions/23190056/hex-to-base64-converter-for-javascript\n * Author: coder hacker (http://stackoverflow.com/users/2277510/coder-hacker)\n */\nif (!window.atob) {\n  var tableStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var table = tableStr.split(\"\");\n\n  window.atob = function (base64) {\n    if (/(=[^=]+|={3,})$/.test(base64)) throw new Error(\"String contains an invalid character\");\n    base64 = base64.replace(/=/g, \"\");\n    var n = base64.length & 3;\n    if (n === 1) throw new Error(\"String contains an invalid character\");\n    for (var i = 0, j = 0, len = base64.length / 4, bin = []; i < len; ++i) {\n      var a = tableStr.indexOf(base64[j++] || \"A\"), b = tableStr.indexOf(base64[j++] || \"A\");\n      var c = tableStr.indexOf(base64[j++] || \"A\"), d = tableStr.indexOf(base64[j++] || \"A\");\n      if ((a | b | c | d) < 0) throw new Error(\"String contains an invalid character\");\n      bin[bin.length] = ((a << 2) | (b >> 4)) & 255;\n      bin[bin.length] = ((b << 4) | (c >> 2)) & 255;\n      bin[bin.length] = ((c << 6) | d) & 255;\n    }\n    return String.fromCharCode.apply(null, bin).substr(0, bin.length + n - 4);\n  };\n\n  window.btoa = function (bin) {\n    for (var i = 0, j = 0, len = bin.length / 3, base64 = []; i < len; ++i) {\n      var a = bin.charCodeAt(j++), b = bin.charCodeAt(j++), c = bin.charCodeAt(j++);\n      if ((a | b | c) > 255) throw new Error(\"String contains an invalid character\");\n      base64[base64.length] = table[a >> 2] + table[((a << 4) & 63) | (b >> 4)] +\n                              (isNaN(b) ? \"=\" : table[((b << 2) & 63) | (c >> 6)]) +\n                              (isNaN(b + c) ? \"=\" : table[c & 63]);\n    }\n    return base64.join(\"\");\n  };\n\n}\n\nfunction hexToBase64(str) {\n  return btoa(String.fromCharCode.apply(null,\n    str.replace(/\\r|\\n/g, \"\").replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \").replace(/ +$/, \"\").split(\" \"))\n  );\n}\n\nfunction base64ToHex(str) {\n  for (var i = 0, bin = atob(str.replace(/[ \\r\\n]+$/, \"\")), hex = []; i < bin.length; ++i) {\n    var tmp = bin.charCodeAt(i).toString(16);\n    if (tmp.length === 1) tmp = \"0\" + tmp;\n    hex[hex.length] = tmp;\n  }\n  return hex.join(\" \");\n}\n\n","/*\n * JavaScript implementation of Password-Based Key Derivation Function 2\n * (PBKDF2) as defined in RFC 2898.\n * Version 1.5 \n * Copyright (c) 2007, 2008, 2009, 2010, 2011, 2012, 2013 Parvez Anandam\n * parvez@anandam.com\n * http://anandam.com/pbkdf2\n *\n * Distributed under the BSD license\n *\n * Uses Paul Johnston's excellent SHA-1 JavaScript library sha1.js:\n * http://pajhome.org.uk/crypt/md5/sha1.html\n * (uses the binb_sha1(), rstr2binb(), binb2str(), rstr2hex() functions from that libary)\n *\n * Thanks to Felix Gartsman for pointing out a bug in version 1.0\n * Thanks to Thijs Van der Schaeghe for pointing out a bug in version 1.1 \n * Thanks to Richard Gautier for asking to clarify dependencies in version 1.2\n * Updated contact information from version 1.3\n * Thanks to Stuart Heinrich for pointing out updates to PAJ's SHA-1 library in version 1.4\n */\n\n\n/*\n * The four arguments to the constructor of the PBKDF2 object are \n * the password, salt, number of iterations and number of bytes in\n * generated key. This follows the RFC 2898 definition: PBKDF2 (P, S, c, dkLen)\n *\n * The method deriveKey takes two parameters, both callback functions:\n * the first is used to provide status on the computation, the second\n * is called with the result of the computation (the generated key in hex).\n *\n * Example of use:\n *\n *    <script src=\"sha1.js\"></script>\n *    <script src=\"pbkdf2.js\"></script>\n *    <script>\n *    var mypbkdf2 = new PBKDF2(\"mypassword\", \"saltines\", 1000, 16);\n *    var status_callback = function(percent_done) {\n *        document.getElementById(\"status\").innerHTML = \"Computed \" + percent_done + \"%\"};\n *    var result_callback = function(key) {\n *        document.getElementById(\"status\").innerHTML = \"The derived key is: \" + key};\n *    mypbkdf2.deriveKey(status_callback, result_callback);\n *    </script>\n *    <div id=\"status\"></div>\n *\n */\n\nfunction PBKDF2(password, salt, num_iterations, num_bytes)\n{\n\t// Remember the password and salt\n\tvar m_bpassword = rstr2binb(password);\n\tvar m_salt = salt;\n\n\t// Total number of iterations\n\tvar m_total_iterations = num_iterations;\n\n\t// Run iterations in chunks instead of all at once, so as to not block.\n\t// Define size of chunk here; adjust for slower or faster machines if necessary.\n\tvar m_iterations_in_chunk = 10;\n\n\t// Iteration counter\n\tvar m_iterations_done = 0;\n\n\t// Key length, as number of bytes\n\tvar m_key_length = num_bytes;\n\n\t// The hash cache\n\tvar m_hash = null;\n\n\t// The length (number of bytes) of the output of the pseudo-random function.\n\t// Since HMAC-SHA1 is the standard, and what is used here, it's 20 bytes.\n\tvar m_hash_length = 20;\n\n\t// Number of hash-sized blocks in the derived key (called 'l' in RFC2898)\n\tvar m_total_blocks = Math.ceil(m_key_length/m_hash_length);\n\n\t// Start computation with the first block\n\tvar m_current_block = 1;\n\n\t// Used in the HMAC-SHA1 computations\n\tvar m_ipad = new Array(16);\n\tvar m_opad = new Array(16);\n\n\t// This is where the result of the iterations gets sotred\n\tvar m_buffer = [0x0,0x0,0x0,0x0,0x0];\n\t\n\t// The result\n\tvar m_key = \"\";\n\n\t// This object\n\tvar m_this_object = this;\n\n\t// The function to call with the result\n\tvar m_result_func;\n\n\t// The function to call with status after computing every chunk\n\tvar m_status_func;\n\t\n\tvar m_stopped = false;\n\t\n\t// Set up the HMAC-SHA1 computations\n\tif (m_bpassword.length > 16) m_bpassword = binb_sha1(m_bpassword, password.length * chrsz);\n\tfor(var i = 0; i < 16; ++i)\n\t{\n\t\tm_ipad[i] = m_bpassword[i] ^ 0x36363636;\n\t\tm_opad[i] = m_bpassword[i] ^ 0x5C5C5C5C;\n\t}\n\n\n\t// Starts the computation\n\tthis.deriveKey = function(status_callback, result_callback)\n\t{\n\t\tm_status_func = status_callback;\n\t\tm_result_func = result_callback;\n\t\tsetTimeout(function() { m_this_object.do_PBKDF2_iterations() }, 0);\n\t};\n\t\n\n\t// The workhorse\n\tthis.do_PBKDF2_iterations = function()\n\t{\n\t\tif (m_stopped) {\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\t\n\t\tvar iterations = m_iterations_in_chunk;\n\t\tif (m_total_iterations - m_iterations_done < m_iterations_in_chunk)\n\t\t\titerations = m_total_iterations - m_iterations_done;\n\t\t\t\n\t\tfor(var i=0; i<iterations; ++i)\n\t\t{\n\t\t\t// compute HMAC-SHA1 \n\t\t\tif (m_iterations_done == 0)\n\t\t\t{\n\t\t\t\tvar salt_block = m_salt +\n\t\t\t\t\t\tString.fromCharCode(m_current_block >> 24 & 0xF) +\n\t\t\t\t\t\tString.fromCharCode(m_current_block >> 16 & 0xF) +\n\t\t\t\t\t\tString.fromCharCode(m_current_block >>  8 & 0xF) +\n\t\t\t\t\t\tString.fromCharCode(m_current_block       & 0xF);\n\n\t\t\t\tm_hash = binb_sha1(m_ipad.concat(rstr2binb(salt_block)),\n\t\t\t\t\t\t\t\t   512 + salt_block.length * 8);\n\t\t\t\tm_hash = binb_sha1(m_opad.concat(m_hash), 512 + 160);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_hash = binb_sha1(m_ipad.concat(m_hash), \n\t\t\t\t\t\t\t\t   512 + m_hash.length * 32);\n\t\t\t\tm_hash = binb_sha1(m_opad.concat(m_hash), 512 + 160);\n\t\t\t}\n\n        \tfor(var j=0; j<m_hash.length; ++j)\n                \tm_buffer[j] ^= m_hash[j];\n\n\t\t\tm_iterations_done++;\n\t\t}\n\n\t\t// Call the status callback function\n\n\t\tif (m_iterations_done < m_total_iterations)\n\t\t{\n\t\t\tsetTimeout(function() { m_this_object.do_PBKDF2_iterations() }, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m_current_block < m_total_blocks)\n\t\t\t{\n\t\t\t\t// Compute the next block (T_i in RFC 2898)\n\t\t\t\tif (m_status_func != null)\n\t\t\t\t\tm_status_func( (m_current_block - 1 + m_iterations_done/m_total_iterations) / m_total_blocks * 100);\n\t\t\t\t\n\t\t\t\tm_key += rstr2hex(binb2rstr(m_buffer));\n\t\t\t\n\t\t\t\tm_current_block++;\n\t\t\t\tm_buffer = [0x0,0x0,0x0,0x0,0x0];\n\t\t\t\tm_iterations_done = 0;\n\n\t\t\t\tsetTimeout(function() { m_this_object.do_PBKDF2_iterations() }, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We've computed the final block T_l; we're done.\n\t\t\t\n\t\t\t\tvar tmp = rstr2hex(binb2rstr(m_buffer));\n\t\t\t\tm_key += tmp.substr(0, (m_key_length - (m_total_blocks - 1) * m_hash_length) * 2 );\n\t\t\t\t\n\t\t\t\t// Call the result callback function\n\t\t\t\tm_result_func(m_key);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis.stop = function()\n\t{\n\t\tm_stopped = true;\n\t}\n}\n","/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS 180-1\n * Version 2.2 Copyright Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }\nfunction b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }\nfunction any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }\nfunction hex_hmac_sha1(k, d)\n  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }\nfunction b64_hmac_sha1(k, d)\n  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }\nfunction any_hmac_sha1(k, d, e)\n  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\").toLowerCase() == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA1 of a raw string\n */\nfunction rstr_sha1(s)\n{\n  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data (raw strings)\n */\nfunction rstr_hmac_sha1(key, data)\n{\n  var bkey = rstr2binb(key);\n  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\n  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));\n}\n\n/*\n * Convert a raw string to a hex string\n */\nfunction rstr2hex(input)\n{\n  try { hexcase } catch(e) { hexcase=0; }\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var output = \"\";\n  var x;\n  for(var i = 0; i < input.length; i++)\n  {\n    x = input.charCodeAt(i);\n    output += hex_tab.charAt((x >>> 4) & 0x0F)\n           +  hex_tab.charAt( x        & 0x0F);\n  }\n  return output;\n}\n\n/*\n * Convert a raw string to a base-64 string\n */\nfunction rstr2b64(input)\n{\n  try { b64pad } catch(e) { b64pad=''; }\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var output = \"\";\n  var len = input.length;\n  for(var i = 0; i < len; i += 3)\n  {\n    var triplet = (input.charCodeAt(i) << 16)\n                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)\n                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > input.length * 8) output += b64pad;\n      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);\n    }\n  }\n  return output;\n}\n\n/*\n * Convert a raw string to an arbitrary string encoding\n */\nfunction rstr2any(input, encoding)\n{\n  var divisor = encoding.length;\n  var remainders = Array();\n  var i, q, x, quotient;\n\n  /* Convert to an array of 16-bit big-endian values, forming the dividend */\n  var dividend = Array(Math.ceil(input.length / 2));\n  for(i = 0; i < dividend.length; i++)\n  {\n    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);\n  }\n\n  /*\n   * Repeatedly perform a long division. The binary array forms the dividend,\n   * the length of the encoding is the divisor. Once computed, the quotient\n   * forms the dividend for the next step. We stop when the dividend is zero.\n   * All remainders are stored for later use.\n   */\n  while(dividend.length > 0)\n  {\n    quotient = Array();\n    x = 0;\n    for(i = 0; i < dividend.length; i++)\n    {\n      x = (x << 16) + dividend[i];\n      q = Math.floor(x / divisor);\n      x -= q * divisor;\n      if(quotient.length > 0 || q > 0)\n        quotient[quotient.length] = q;\n    }\n    remainders[remainders.length] = x;\n    dividend = quotient;\n  }\n\n  /* Convert the remainders to the output string */\n  var output = \"\";\n  for(i = remainders.length - 1; i >= 0; i--)\n    output += encoding.charAt(remainders[i]);\n\n  /* Append leading zero equivalents */\n  var full_length = Math.ceil(input.length * 8 /\n                                    (Math.log(encoding.length) / Math.log(2)));\n  for(i = output.length; i < full_length; i++)\n    output = encoding[0] + output;\n\n  return output;\n}\n\n/*\n * Encode a string as utf-8.\n * For efficiency, this assumes the input is valid utf-16.\n */\nfunction str2rstr_utf8(input)\n{\n  var output = \"\";\n  var i = -1;\n  var x, y;\n\n  while(++i < input.length)\n  {\n    /* Decode utf-16 surrogate pairs */\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    /* Encode output as utf-8 */\n    if(x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if(x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if(x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if(x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n}\n\n/*\n * Encode a string as utf-16\n */\nfunction str2rstr_utf16le(input)\n{\n  var output = \"\";\n  for(var i = 0; i < input.length; i++)\n    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,\n                                  (input.charCodeAt(i) >>> 8) & 0xFF);\n  return output;\n}\n\nfunction str2rstr_utf16be(input)\n{\n  var output = \"\";\n  for(var i = 0; i < input.length; i++)\n    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,\n                                   input.charCodeAt(i)        & 0xFF);\n  return output;\n}\n\n/*\n * Convert a raw string to an array of big-endian words\n * Characters >255 have their high-byte silently ignored.\n */\nfunction rstr2binb(input)\n{\n  var output = Array(input.length >> 2);\n  for(var i = 0; i < output.length; i++)\n    output[i] = 0;\n  for(var i = 0; i < input.length * 8; i += 8)\n    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);\n  return output;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2rstr(input)\n{\n  var output = \"\";\n  for(var i = 0; i < input.length * 32; i += 8)\n    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);\n  return output;\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction binb_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = bit_rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}","var mypbkdf2 = null;\n\nvar passwordLib = (function () {\n\t\"use strict\";\n\treturn {\n\t\tcalculatePassword: calculatePassword,\n\t\tcalculatePasswordOld: calculatePasswordOld,\n\t\tgetBaseUrl: getBaseUrl,\n\t\tgetDomain: getDomain,\n\t\tgetDefaultOptions: getDefaultOptions\n\t};\n\n\tfunction calculatePassword(originalPassword, url, options) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar intOptions = getDefaultOptions();\n\n\t\t\tif (typeof options !== 'undefined') {\n\t\t\t\t// Merge the options\n\t\t\t\tfor (var attrname in options) {\n\t\t\t\t\tintOptions[attrname] = options[attrname];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.verbose)\n\t\t\t\tconsole.log('calculatePassword', 'url:', url, 'options:', intOptions);\n\n\n\t\t\tif (originalPassword.trim() == '') {\n\t\t\t\t// Skip calculation for an empty password\n\t\t\t\tresolve('');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar domain = getDomain(url);\n\t\t\tvar salt = getBaseUrl(domain);\n\n\t\t\tif (options.verbose)\n\t\t\t\tconsole.log('calculatePassword, salt:', salt);\n\n\t\t\t// Encrypt password using the original password and the given salt value\n\t\t\tvar iterations = intOptions.baseIterations + (salt.length + originalPassword.length + 1);\n\n\t\t\tif (mypbkdf2 != null)\n\t\t\t\tmypbkdf2.stop();\n\n\t\t\tmypbkdf2 = new PBKDF2(originalPassword, salt, iterations, 128);\n\n\t\t\tvar intResultCallback = function (key) {\n\t\t\t\tcalculatePasswordInternal(key, salt, intOptions, resolve, reject);\n\t\t\t};\n\t\t\tmypbkdf2.deriveKey(options.statusCallback, intResultCallback);\n\n\t\t});\n\n\t}\n\n\tfunction calculatePasswordInternal(key, salt, options, resultCallback, rejectCallback) {\n\t\tvar base64 = hexToBase64(key);\n\n\t\t// Generate actual password (based on encrypted password), using the given criteria\n\t\tvar typeCount = 0;\n\t\tif (options.smallChars)\n\t\t\ttypeCount++;\n\t\tif (options.capitalChars)\n\t\t\ttypeCount++;\n\t\tif (options.numbers)\n\t\t\ttypeCount++;\n\t\tif (options.specialChars)\n\t\t\ttypeCount++;\n\n\t\tvar prefix = \"\";\n\t\tvar newPassword = \"\";\n\t\tvar specialCharsListStart = salt.length % options.specialCharList.length;\n\n\t\tvar smallCharsAdded = false;\n\t\tvar capitalCharsAdded = false;\n\t\tvar numbersAdded = false;\n\t\tvar specialCharsAdded = false;\n\t\tvar charAdded = false;\n\n\t\tfor (var i = 0; i < base64.length; i++) {\n\t\t\tvar curChar = base64.charAt(i);\n\t\t\tvar charCode = curChar.charCodeAt();\n\n\t\t\tcharAdded = false;\n\n\n\t\t\tif (typeCount > 0) {\n\t\t\t\t// Generate prefix, containing one of each\n\t\t\t\tif (options.smallChars && !smallCharsAdded && charCode >= 97\n\t\t\t\t\t\t&& charCode <= 122) {\n\t\t\t\t\tprefix += curChar;\n\t\t\t\t\tsmallCharsAdded = true;\n\t\t\t\t\ttypeCount--;\n\t\t\t\t\tcharAdded = true;\n\t\t\t\t} else if (options.capitalChars && !capitalCharsAdded && charCode >= 65\n\t\t\t\t\t\t&& charCode <= 90) {\n\t\t\t\t\tprefix += curChar;\n\t\t\t\t\tcapitalCharsAdded = true;\n\t\t\t\t\ttypeCount--;\n\t\t\t\t\tcharAdded = true;\n\t\t\t\t} else if (options.numbers && !numbersAdded && charCode >= 48\n\t\t\t\t\t\t&& charCode <= 57) {\n\t\t\t\t\tprefix += curChar;\n\t\t\t\t\tnumbersAdded = true;\n\t\t\t\t\ttypeCount--;\n\t\t\t\t\tcharAdded = true;\n\t\t\t\t} else if (options.specialChars && !specialCharsAdded\n\t\t\t\t\t\t&& (charCode == 43 || charCode == 47 || charCode == 61)) {\n\t\t\t\t\tprefix += options.specialCharList.charAt((specialCharsListStart + i)\n\t\t\t\t\t\t\t% options.specialCharList.length);\n\t\t\t\t\tspecialCharsAdded = true;\n\t\t\t\t\ttypeCount--;\n\t\t\t\t\tcharAdded = true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!charAdded) {\n\t\t\t\tif (options.smallChars && charCode >= 97 && charCode <= 122) {\n\t\t\t\t\tnewPassword += curChar;\n\t\t\t\t} else if (options.capitalChars && charCode >= 65 && charCode <= 90) {\n\t\t\t\t\tnewPassword += curChar;\n\t\t\t\t} else if (options.numbers && charCode >= 48 && charCode <= 57) {\n\t\t\t\t\tnewPassword += curChar;\n\t\t\t\t} else if (options.specialChars\n\t\t\t\t\t\t&& (charCode == 43 || charCode == 47 || charCode == 61)) {\n\t\t\t\t\tnewPassword += options.specialCharList\n\t\t\t\t\t\t\t.charAt((specialCharsListStart + i)\n\t\t\t\t\t\t\t\t\t% options.specialCharList.length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeCount == 0 && prefix.length + newPassword.length >= options.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tresultCallback((prefix + newPassword).substring(0, options.length));\n\n\t}\n\n\t/**\n\t * @deprecated old version, obsolete, use calculatePassword() instead\n\t */\n\tfunction calculatePasswordOld(originalPassword, url, length, smallChars, capitalChars, numbers, specialChars, specialCharList, resultCallback){\n\t\tif (originalPassword.trim() == '') {\n\t\t\t// Skip calculation for an empty password\n\t\t\treturn '';\n\t\t}\n\n\t\tvar domain = getDomain(url);\n\t\tvar salt = getBaseUrl(domain);\n\t\tvar saltedPassword = salt+originalPassword;\n\n\t\tvar newPassword = hex_sha1(saltedPassword);\n\t\tnewPassword = newPassword.substring(0,length);\n\n\t\tvar moduloSpecialChars = saltedPassword.length % (length - 3) + 3;\n\t\tvar moduloLargeChars = saltedPassword.length % 2 +2;\n\n\t\tvar specialCharsListStart = salt.length % specialCharList.length;\n\n\t\tif (!numbers){\n\t\t\tvar tempPassword = '';\n\t\t\tfor(i=0;i<newPassword.length; i++){\n\t\t\t\tif (!isNaN(newPassword.substring(i,i+1))){\n\t\t\t\t\ttempPassword += String.fromCharCode(97+parseInt(newPassword.charAt(i)));\n\t\t\t\t} else {\n\t\t\t\t\ttempPassword += newPassword.charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewPassword = tempPassword;\n\t\t}\n\n\t\tif (!smallChars){\n\t\t\tif (capitalChars){\n\t\t\t\tnewPassword = newPassword.toUpperCase();\n\t\t\t} else if (numbers){\n\t\t\t\ttempPassword = '';\n\t\t\t\tfor(var i=0;i<newPassword.length; i++){\n\t\t\t\t\ttempPassword += newPassword.charCodeAt(i) % 10;\n\t\t\t\t}\n\t\t\t\tnewPassword = tempPassword;\n\t\t\t}\n\t\t}\n\t\tif (capitalChars && smallChars){\n\t\t\ttempPassword = '';\n\t\t\tvar c = 0;\n\t\t\tfor(var i=0;i<newPassword.length; i++){\n\t\t\t\tvar character = newPassword.charAt(i);\n\t\t\t\tif (isNaN(character)){\n\t\t\t\t\tif (c % moduloLargeChars == 0)\n\t\t\t\t\t\ttempPassword += character.toUpperCase();\n\t\t\t\t\telse\n\t\t\t\t\t\ttempPassword += character;\n\t\t\t\t\tc++;\n\t\t\t\t} else {\n\t\t\t\t\ttempPassword += character;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewPassword = tempPassword;\n\t\t}\n\n\t\tif (specialChars){\n\t\t\ttempPassword = '';\n\t\t\tfor(var i=0;i<newPassword.length; i++){\n\t\t\t\tif (i>0 && i % moduloSpecialChars == 0){\n\t\t\t\t\ttempPassword += specialCharList.charAt((specialCharsListStart*i)%specialCharList.length);\n\t\t\t\t} else {\n\t\t\t\t\ttempPassword += newPassword.charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewPassword = tempPassword;\n\n\t\t}\n\n\t\tresultCallback(newPassword);\n\n\t}\n\n\n\t/**\n   * Returns the base url from a given domain.\n\t * The base url is the domain name without the superdomain, e.g. for www.foobar.com it returns foobar.\n\t *\n\t * @param domain Domain to parse\n\t * @return base url of given domain\n\t *\n\t */\n\tfunction getBaseUrl(domain) {\n\n\t\tif (domain && domain !== '') {\n\n\t\t\tvar parts = domain.split('.').reverse();\n\t\t\tvar cnt = parts.length;\n\t\t\tif (cnt >= 3) {\n\t\t\t\t// see if the second level domain is a common SLD.\n\t\t\t\tif (parts[1].match(/^(com|edu|gov|net|mil|org|nom|co|name|info|biz)$/i)) {\n\t\t\t\t\treturn parts[2];\n\t\t\t\t} else {\n\t\t\t\t\treturn parts[1];\n\t\t\t\t}\n\t\t\t} else if (cnt >= 2) {\n\t\t\t\treturn parts[1];\n\t\t\t} else {\n\t\t\t\treturn domain;\n\t\t\t}\n\t\t}\n\n\t\treturn domain;\n\t}\n\n\t/**\n\t * Returns the domain name for a given url\n\t *\n\t * @param origUrl\toriginal url to be parsed\n\t * @return domain for given origUrl\n\t *\n\t */\n\tfunction getDomain(origUrl) {\n\t\tif (!origUrl)\n\t\t\treturn origUrl;\n\n\t\tvar parser = document.createElement('a');\n\n\t\tvar origUrlLower = origUrl.toLowerCase().replace('&nbsp;', '');\n\t\tvar url = origUrlLower;\n\n\t\tparser.href = url;\n\n\t\tif ((parser.host.indexOf('magic-key') >= 0 && origUrlLower.indexOf('magic-key') == -1)\n\t\t\t\t|| (parser.host.indexOf('localhost') >= 0 && origUrlLower.indexOf('localhost') == -1)) {\n\t\t\t// This is handled as a relative url, change it to an absolute one\n\t\t\turl = 'http://'+url;\n\t\t\tparser.href = url;\n\t\t}\n\n\t\treturn parser.hostname;\n\t}\n\n\t/**\n\t * Returns the default options used for the calculation of the password.$\n\t * @return Object containing the default options.\n\t */\n\tfunction getDefaultOptions() {\n\t\treturn {\n\t\t\tlength: 20,\n\t\t\tsmallChars: true,\n\t\t\tcapitalChars: true,\n\t\t\tnumbers: true,\n\t\t\tspecialChars: true,\n\t\t\tspecialCharList: '][?/<~#`!@$%^&*()+=}|:\";\\',>{',\n\t\t\tbaseIterations: 100,\n\t\t\tstatusCallback: undefined\n\t\t};\n\t}\n\n\n}());"],"sourceRoot":"/source/"}